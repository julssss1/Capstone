<!-- START OF FILE templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sign Language Practice</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .main-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
            align-items: flex-start; /* Align items to the top */
            gap: 30px; /* Space between video and practice area */
            width: 100%;
            max-width: 1200px; /* Limit overall width */
        }

        #video-container {
            position: relative;
            width: 100%;
            max-width: 640px; /* Limit video width */
            border: 2px solid #34495e;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: #000; /* Black background for loading/error */
            overflow: hidden;
             margin-bottom: 15px; /* Add space below video on mobile */
        }

        #video-feed {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 6px; /* Slightly smaller radius than container */
        }

        #practice-area {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            text-align: center;
            width: 100%;
            max-width: 350px; /* Limit practice area width */
            display: flex;
            flex-direction: column;
        }

         #practice-area h2 {
            margin-top: 0;
            color: #34495e;
            margin-bottom: 15px;
         }

        #sign-buttons {
            margin-bottom: 20px; /* Space below buttons */
        }

        #sign-buttons p {
             margin-bottom: 10px;
             color: #555;
             font-weight: bold;
        }

        #sign-buttons button {
            background-color: #3498db; /* Blue */
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        #sign-buttons button:hover {
            background-color: #2980b9; /* Darker blue */
        }
        #sign-buttons button:active {
            transform: scale(0.95); /* Click effect */
        }

         #sign-buttons button.active {
             background-color: #e67e22; /* Orange when active */
             font-weight: bold;
             box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
         }


        #target-sign-display {
            margin-top: auto; /* Pushes this section towards bottom if practice-area grows */
            min-height: 230px; /* Ensure consistent space for image+text+feedback */
            display: flex;
            flex-direction: column;
            align-items: center;
            border-top: 1px solid #eee; /* Separator line */
            padding-top: 15px;
        }
         #target-sign-display p#instruction-text { /* Specific targeting */
             font-size: 1.1em;
             margin-bottom: 10px;
             color: #333;
             min-height: 2.4em; /* Reserve space for two lines */
             display: flex;
             align-items: center;
             justify-content: center;
         }

        #target-image {
            max-width: 150px;
            max-height: 150px;
            width: auto;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            background-color: #eee; /* Background while loading/hidden */
        }

        #feedback {
            margin-top: 10px;
            font-size: 1.2em;
            font-weight: bold;
            min-height: 30px; /* Prevent layout shift */
            color: #555; /* Default text color */
            transition: color 0.3s ease; /* Smooth color transition */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #feedback.success {
            color: #2ecc71; /* Green */
        }
        #feedback.incorrect {
             color: #e74c3c; /* Red */
         }
         #feedback.holding {
            color: #f39c12; /* Yellow/Orange */
         }

         #debug-info {
             margin-top:20px;
             font-size: 0.9em;
             color: #777;
             border-top: 1px dashed #ccc;
             padding-top: 10px;
         }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .main-container {
                flex-direction: column; /* Stack elements vertically */
                align-items: center; /* Center stack */
                gap: 20px;
            }
            #video-container {
                max-width: 95%;
            }
             #practice-area {
                max-width: 95%;
                margin-top: 0;
             }
             #target-sign-display {
                min-height: 200px; /* Slightly less space needed on mobile */
             }
        }
    </style>
</head>
<body>
    <h1>Sign Language Practice</h1>

    <div class="main-container">
        <div id="video-container">
            <!-- Video feed from Flask -->
            <img id="video-feed" src="{{ url_for('video_feed') }}" alt="Loading video stream...">
        </div>

        <div id="practice-area">
            <h2>Practice a Sign</h2>
            <div id="sign-buttons">
                 <p>Select a sign to practice:</p>
                <!-- Buttons are generated by Flask/Jinja -->
                {% for sign in available_signs %}
                    <button onclick="startPractice('{{ sign }}')">{{ sign }}</button>
                {% endfor %}
            </div>

            <!-- Area to show target sign and feedback -->
            <div id="target-sign-display">
                <p id="instruction-text">Select a sign above to begin.</p>
                <img id="target-image" src="" alt="Sign to practice" style="display: none;">
                <div id="feedback">Waiting for practice...</div>
            </div>

             <!-- Display the stable prediction (optional, mostly for debugging) -->
             <div id="debug-info">
                Stable Detected: <span id="detected-sign-display">...</span>
             </div>
        </div>
    </div>

    <script>
        // --- Get DOM Elements ---
        const predictionDisplayElement = document.getElementById('detected-sign-display');
        const videoElement = document.getElementById('video-feed');
        const instructionTextElement = document.getElementById('instruction-text');
        const targetImageElement = document.getElementById('target-image');
        const feedbackElement = document.getElementById('feedback');
        const signButtons = document.querySelectorAll('#sign-buttons button'); // Get all practice buttons

        // --- State Variables ---
        let currentTargetSign = null; // The sign the user is currently trying to make (e.g., "A")
        let stablePrediction = "..."; // Store the latest stable prediction received from backend
        let correctSignStartTime = null; // Timestamp (ms) when correct sign was first detected stably
        const REQUIRED_HOLD_TIME_MS = 2000; // Hold for 2 seconds (Adjust as needed)
        const POLLING_INTERVAL_MS = 250; // Check prediction from backend every 250ms (Adjust as needed)

        let pollingTimer = null; // Holds the interval timer ID

        // --- Practice Control ---
        function startPractice(sign) {
            console.log("Starting practice for:", sign);
            currentTargetSign = sign;
            correctSignStartTime = null; // Reset hold timer

            // --- Update UI Elements ---
            instructionTextElement.textContent = `Now, make the sign for: ${sign}`;
            // Assumes images are in /static/ and named like A.png, B.png
            targetImageElement.src = `/static/${sign.toUpperCase()}.png`;
            targetImageElement.alt = `Example sign for ${sign}`;
            targetImageElement.style.display = 'block'; // Show the image
            feedbackElement.textContent = 'Hold the sign...';
            feedbackElement.className = ''; // Reset feedback color/style

             // Highlight the active button and deactivate others
             signButtons.forEach(button => {
                 if (button.textContent === sign) {
                     button.classList.add('active');
                 } else {
                     button.classList.remove('active');
                 }
             });

            // --- Start/Ensure Polling ---
            // Clear any existing timer before starting a new one
            if (pollingTimer) {
                clearInterval(pollingTimer);
            }
            // Start polling the backend for predictions
            pollingTimer = setInterval(fetchPredictionAndCheck, POLLING_INTERVAL_MS);
            // Fetch immediately once to get the initial state after selection
            fetchPredictionAndCheck();
        }

        // --- Prediction Fetching and Checking ---
        async function fetchPredictionAndCheck() {
            // Only proceed if we are actively practicing a sign
            if (!currentTargetSign) {
                // console.log("Polling skipped, no target sign.");
                return;
            }

            try {
                // Fetch the latest stable prediction from the Flask backend /get_prediction endpoint
                const response = await fetch('/get_prediction');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const predictionText = await response.text();
                stablePrediction = predictionText || "..."; // Update global JS variable
                predictionDisplayElement.textContent = stablePrediction; // Update the debug display

                updateFeedback(); // Check if the detected sign matches the target

            } catch (error) {
                console.error('Error fetching prediction:', error);
                stablePrediction = "Conn Error"; // Indicate a connection error
                predictionDisplayElement.textContent = stablePrediction;
                feedbackElement.textContent = 'Connection Error';
                feedbackElement.className = 'incorrect';
                // Maybe stop polling on repeated errors?
                 if (pollingTimer) {
                    clearInterval(pollingTimer);
                    pollingTimer = null;
                }
            }
        }

        // --- Feedback Logic ---
        function updateFeedback() {
            // Should only update feedback if a practice target is set
            if (!currentTargetSign) {
                 feedbackElement.textContent = 'Select a sign to practice.';
                 feedbackElement.className = '';
                 return;
            }

            // Compare detected sign with target sign (case-insensitive)
            const currentStableUpper = stablePrediction.toUpperCase();
            const targetUpper = currentTargetSign.toUpperCase();

            if (currentStableUpper === targetUpper) {
                // --- CORRECT SIGN DETECTED ---
                if (correctSignStartTime === null) {
                    // Correct sign detected for the first time (stably), start the timer
                    correctSignStartTime = Date.now();
                    feedbackElement.textContent = 'Keep holding...';
                    feedbackElement.className = 'holding'; // Yellow/Orange color
                } else {
                    // Correct sign is still being held, check elapsed time
                    const elapsedTime = Date.now() - correctSignStartTime;
                    if (elapsedTime >= REQUIRED_HOLD_TIME_MS) {
                        // --- SUCCESS: Held long enough! ---
                        feedbackElement.textContent = `Correct! You held '${currentTargetSign}'!`;
                        feedbackElement.className = 'success'; // Green color

                        // Stop checking for this sign (practice complete for this round)
                        currentTargetSign = null;
                        correctSignStartTime = null;

                        // Stop polling
                        if (pollingTimer) {
                            clearInterval(pollingTimer);
                            pollingTimer = null;
                        }

                        // Remove active class from button after success
                        signButtons.forEach(button => button.classList.remove('active'));

                        // Optionally, update instruction text after success
                        instructionTextElement.textContent = "Well done! Select another sign.";
                    } else {
                        // --- STILL HOLDING CORRECTLY (Timer running) ---
                        // Update feedback with remaining time (optional but helpful)
                         const remaining = ((REQUIRED_HOLD_TIME_MS - elapsedTime) / 1000).toFixed(1);
                        feedbackElement.textContent = `Keep holding... (${remaining}s)`;
                        feedbackElement.className = 'holding'; // Yellow/Orange color
                    }
                }
            } else {
                // --- INCORRECT SIGN or NO/ERROR DETECTION ---
                correctSignStartTime = null; // Reset timer if sign is wrong or lost

                if (stablePrediction === "..." || stablePrediction === "No hand detected" || stablePrediction === "Initializing...") {
                     // Waiting for a hand or stable prediction
                     feedbackElement.textContent = `Show the '${currentTargetSign}' sign...`;
                     feedbackElement.className = ''; // Default color
                } else if (stablePrediction === "Error" || stablePrediction === "Conn Error" || stablePrediction === "Processing Error" || stablePrediction === "System Error") {
                     // Show system/connection errors distinctly
                     feedbackElement.textContent = `System Status: ${stablePrediction}`;
                     feedbackElement.className = 'incorrect'; // Red color
                }
                 else {
                    // A specific, but incorrect, sign is detected
                    feedbackElement.textContent = `Detected: ${stablePrediction}. Try '${currentTargetSign}'!`;
                    feedbackElement.className = 'incorrect'; // Red color
                }
            }
        }

        // --- Video Stream Event Handlers ---
        videoElement.onerror = () => {
            console.error("Video stream failed to load.");
             instructionTextElement.textContent = "Camera Error!";
             targetImageElement.style.display = 'none'; // Hide image placeholder
             feedbackElement.textContent = "Cannot load camera feed.";
             feedbackElement.className = 'incorrect'; // Red color
             predictionDisplayElement.textContent = "N/A";
             // Stop polling if video fails
            if (pollingTimer) {
                clearInterval(pollingTimer);
                pollingTimer = null;
                console.log("Prediction polling stopped due to video error.");
            }
        };

        videoElement.onload = () => {
            console.log("Video stream started successfully.");
            // Polling is now started within startPractice when a sign is selected.
            // We can fetch the initial prediction state for the debug display here.
            fetch('/get_prediction')
                .then(r => r.ok ? r.text() : Promise.reject(`HTTP ${r.status}`))
                .then(text => predictionDisplayElement.textContent = text || "...")
                .catch(err => {
                    console.error("Initial prediction fetch failed:", err);
                    predictionDisplayElement.textContent = "Error";
                });
        };

    </script>
</body>
</html>
<!-- END OF FILE templates/index.html -->